// generated by `sqlx migrate build-script`
// Augmented to propagate compile-time env vars for SQLx macros.
fn main() {
    use std::env;

    // trigger recompilation when a new migration is added
    println!("cargo:rerun-if-changed=migrations");

    // Load .env so we can derive DATABASE_URL at compile time
    let _ = dotenvy::dotenv();

    // Derive DATABASE_URL from POSTGRES_* vars if not already set
    let db_url = env::var("DATABASE_URL")
        .ok()
        .or_else(|| {
            let host = env::var("POSTGRES_HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
            let port = env::var("POSTGRES_PORT").unwrap_or_else(|_| "5432".to_string());
            let user = env::var("POSTGRES_USER").unwrap_or_else(|_| "postgres".to_string());
            let pass = env::var("POSTGRES_PASSWORD").unwrap_or_else(|_| "".to_string());
            let db = env::var("POSTGRES_DB").unwrap_or_else(|_| "postgres".to_string());
            Some(format!(
                "postgresql://{}:{}@{}:{}/{}?schema=public",
                user, pass, host, port, db
            ))
        })
        .unwrap();

    // Ensure SQLx macros have access to the connection string
    println!("cargo:rustc-env=DATABASE_URL={}", db_url);

    // Default to online mode locally unless explicitly set to true
    let sqlx_offline = env::var("SQLX_OFFLINE").unwrap_or_else(|_| "false".to_string());
    println!("cargo:rustc-env=SQLX_OFFLINE={}", sqlx_offline);

    // Re-run build if any of these envs change
    println!("cargo:rerun-if-env-changed=DATABASE_URL");
    println!("cargo:rerun-if-env-changed=SQLX_OFFLINE");
    println!("cargo:rerun-if-env-changed=POSTGRES_HOST");
    println!("cargo:rerun-if-env-changed=POSTGRES_PORT");
    println!("cargo:rerun-if-env-changed=POSTGRES_USER");
    println!("cargo:rerun-if-env-changed=POSTGRES_PASSWORD");
    println!("cargo:rerun-if-env-changed=POSTGRES_DB");
}
